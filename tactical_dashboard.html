<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactical Intelligence Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            color: white;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header .updated {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .location-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .location-header {
            background: #4a90e2;
            color: white;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .location-header:hover {
            background: #357abd;
        }

        .location-content {
            display: none;
            padding: 0;
        }

        .location-content.expanded {
            display: block;
        }

        .tab-container {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
        }

        .tab-header {
            flex: 1;
            background: #4a90e2;
            padding: 12px 20px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            text-align: center;
            border-bottom: 3px solid #2c5899;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .tab-header:first-child {
            border-right: 1px solid #e0e0e0;
        }

        .tab-header:first-child.active {
            border-right: 3px solid #2c5899;
        }

        .tab-header:last-child.active {
            border-left: 3px solid #2c5899;
            margin-left: -1px;
        }

        .tab-header:hover:not(.active) {
            background: #357abd;
        }

        .tab-header.active {
            background: #f5f5f5;
            color: #666;
            border-top: 3px solid #2c5899;
            border-bottom: none;
            font-weight: bold;
        }

        .tab-header:first-child.active {
            border-right: 3px solid #2c5899;
        }

        .tab-header:last-child.active {
            border-left: 3px solid #2c5899;
        }

        .tab-header .count {
            background: rgba(255, 255, 255, 0.2);
            color: inherit;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.8em;
            min-width: 20px;
        }

        .tab-header.active .count {
            background: rgba(255, 255, 255, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .member-row {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            border-bottom: 1px solid #f0f0f0;
        }

        .member-row:last-child {
            border-bottom: none;
        }

        .member-row:hover {
            background: #f9f9f9;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .status-dot.online {
            background: #4CAF50;
        }

        .status-dot.idle {
            background: #FFC107;
        }

        .status-dot.offline {
            background: #9E9E9E;
        }

        .member-name {
            flex: 1;
            font-weight: 500;
        }

        .member-link {
            color: #4a90e2;
            text-decoration: none;
            transition: color 0.2s;
        }

        .member-link:hover {
            color: #357abd;
            text-decoration: underline;
        }

        .attack-link {
            color: #dc3545;
            text-decoration: none;
            font-size: 0.9em;
            margin-left: 8px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .attack-link:hover {
            opacity: 1;
        }

        .member-status {
            color: #666;
            font-size: 0.9em;
            margin-right: 15px;
        }

        .member-level {
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: 500;
            margin-right: 8px;
            min-width: 30px;
            text-align: center;
            border: 1px solid #bbdefb;
        }

        .member-countdown {
            font-family: monospace;
            background: #f0f0f0;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #333;
            min-width: 70px;
            text-align: center;
            margin-right: 8px;
            margin-bottom: 4px;
        }

        .member-countdown.warning {
            background: #F44336;
            color: #fff;
        }

        .member-countdown.urgent {
            background: #FFC107;
            color: #000;
        }

        .dual-arrival-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: flex-end;
        }

        .arrival-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .arrival-label {
            font-size: 0.8em;
            color: #666;
            min-width: 60px;
            text-align: right;
        }

        .sort-controls {
            background: #f8f9fa;
            padding: 8px 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 0.9em;
        }

        .sort-label {
            color: #666;
            font-weight: 500;
        }

        .sort-option {
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            color: #666;
            transition: all 0.2s;
            font-size: 0.8em;
        }

        .sort-option:hover {
            background: #e3f2fd;
            border-color: #1976d2;
            color: #1976d2;
        }

        .sort-option.active {
            background: #1976d2;
            border-color: #1976d2;
            color: white;
        }

        .sort-divider {
            color: #ccc;
        }


        .expand-icon {
            font-size: 0.8em;
            transition: transform 0.2s;
        }

        .location-header.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .empty-section {
            padding: 20px;
            text-align: center;
            color: #999;
            font-style: italic;
        }

        .note {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="faction-name">Loading...</h1>
            <div class="updated" id="last-updated">Loading...</div>
            <div class="updated" id="update-interval">Update interval: Loading...</div>
        </div>

        <div id="locations-container">
            <!-- Locations will be populated by JavaScript -->
        </div>

        <div class="note">
            <strong>Note:</strong> Green status indicates online players, yellow indicates idle players, grey indicates offline players. Travel countdowns show time until arrival. Status countdowns show remaining time in hospital, jail, etc. Red countdown backgrounds indicate immediate attention needed (less than 10 minutes), yellow countdown backgrounds indicate medium-term awareness (10-60 minutes).
        </div>
    </div>

    <script>
        // Global variables
        let currentData = null;
        let refreshInterval = null;
        let currentIntervalId = null;
        let countdownTimers = new Map(); // Track countdown end times
        let countdownIntervalId = null;

        // API endpoint for live data
        const API_ENDPOINT = 'https://gefunkt.dev/travel_data.json';

        // Fetch data from API
        async function fetchData() {
            try {
                const response = await fetch(API_ENDPOINT);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching data:', error);
                return null;
            }
        }

        function getStatusDotClass(state) {
            switch (state.toLowerCase()) {
                case 'online': return 'online';
                case 'idle': return 'idle';
                case 'offline': return 'offline';
                default: return 'offline';
            }
        }

        function parseTimeToMinutes(timeString) {
            if (!timeString) return 0;

            const parts = timeString.split(':');
            if (parts.length === 3) {
                // H:MM:SS format
                const hours = parseInt(parts[0], 10);
                const minutes = parseInt(parts[1], 10);
                return hours * 60 + minutes;
            } else if (parts.length === 2) {
                // M:SS format
                const minutes = parseInt(parts[0], 10);
                return minutes;
            }
            return 0;
        }


        function formatSecondsToTime(totalSeconds) {
            if (totalSeconds <= 0) return '0:00:00';

            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function startRealtimeCountdowns() {
            // Clear existing countdown timer
            if (countdownIntervalId) {
                clearInterval(countdownIntervalId);
            }

            // Initialize countdown end times from DOM elements
            countdownTimers.clear();
            const currentTime = Date.now();

            // Only handle calculated countdown elements now

            // Handle arrival-based countdown elements
            const arrivalElements = document.querySelectorAll('.member-countdown[data-arrival-time]');
            arrivalElements.forEach(element => {
                const arrivalTimeStr = element.getAttribute('data-arrival-time');
                if (arrivalTimeStr) {
                    // Parse arrival time (format: "2025-09-17 14:23:45")
                    const arrivalTime = new Date(arrivalTimeStr.replace(' ', 'T') + 'Z').getTime();
                    if (!isNaN(arrivalTime)) {
                        countdownTimers.set(element.id, arrivalTime);
                    }
                }
            });

            // Handle until-based countdown elements (for hospital/jail)
            const untilElements = document.querySelectorAll('.member-countdown[data-until-time]');
            untilElements.forEach(element => {
                const untilTimeStr = element.getAttribute('data-until-time');
                if (untilTimeStr) {
                    // Parse until time (format: "2025-09-17T14:23:45Z")
                    const untilTime = new Date(untilTimeStr).getTime();
                    if (!isNaN(untilTime)) {
                        countdownTimers.set(element.id, untilTime);
                    }
                }
            });

            // Start the countdown update interval
            countdownIntervalId = setInterval(updateCountdowns, 1000);
        }

        function updateCountdowns() {
            const currentTime = Date.now();
            let hasActiveCountdowns = false;

            countdownTimers.forEach((endTime, countdownId) => {
                const element = document.getElementById(countdownId);
                if (!element) {
                    countdownTimers.delete(countdownId);
                    return;
                }

                const remainingMs = endTime - currentTime;
                if (remainingMs <= 0) {
                    element.textContent = '0:00:00';
                    element.className = 'member-countdown warning';
                    countdownTimers.delete(countdownId);
                } else {
                    hasActiveCountdowns = true;
                    const remainingSeconds = Math.floor(remainingMs / 1000);
                    const timeString = formatSecondsToTime(remainingSeconds);

                    element.textContent = timeString;

                    // Update the color class based on remaining time
                    const remainingMinutes = Math.floor(remainingSeconds / 60);
                    let newClass = 'member-countdown';
                    if (remainingMinutes < 10) {
                        newClass += ' warning';
                    } else if (remainingMinutes >= 10 && remainingMinutes <= 60) {
                        newClass += ' urgent';
                    }
                    element.className = newClass;
                }
            });

            // Stop the interval if no active countdowns remain
            if (!hasActiveCountdowns && countdownTimers.size === 0) {
                clearInterval(countdownIntervalId);
                countdownIntervalId = null;
            }
        }


        function createMemberRow(member, locationId) {
            const statusClass = getStatusDotClass(member.State);
            const statusText = member.Status || '';

            // Create unique ID for this member's countdown
            const memberKey = `${locationId}-${member.Name.replace(/\s+/g, '-')}`;
            const arrivalCountdownId = `arrival-countdown-${memberKey}`;
            const untilCountdownId = `until-countdown-${memberKey}`;

            // Create member name with profile link and attack link if MemberID is available
            const memberNameHtml = member.MemberID
                ? `<a href="https://www.torn.com/profiles.php?XID=${member.MemberID}" target="_blank" class="member-link">${member.Name}</a><a href="https://www.torn.com/loader.php?sid=attack&user2ID=${member.MemberID}" target="_blank" class="attack-link" title="Attack ${member.Name}">ðŸ”«</a>`
                : member.Name;

            // Build countdown displays - use calculated countdowns only
            let countdownHtml = '';

            // Show calculated countdown for traveling members (from Arrival)
            if (member.Arrival) {
                // If we have both arrival times, show both with labels
                if (member.BusinessArrival && member.BusinessArrival !== member.Arrival) {
                    const businessCountdownId = `business-countdown-${memberKey}`;
                    countdownHtml = `
                        <div class="dual-arrival-container">
                            <div class="arrival-row">
                                <span class="arrival-label">Regular:</span>
                                <div class="member-countdown" id="${arrivalCountdownId}" data-arrival-time="${member.Arrival}">Calculating...</div>
                            </div>
                            <div class="arrival-row">
                                <span class="arrival-label">Business:</span>
                                <div class="member-countdown" id="${businessCountdownId}" data-arrival-time="${member.BusinessArrival}">Calculating...</div>
                            </div>
                        </div>
                    `;
                } else {
                    // Single arrival time
                    countdownHtml = `<div class="member-countdown" id="${arrivalCountdownId}" data-arrival-time="${member.Arrival}">Calculating...</div>`;
                }
            }
            // Show calculated countdown for located members (from Until)
            else if (member.Until) {
                countdownHtml = `<div class="member-countdown" id="${untilCountdownId}" data-until-time="${member.Until}">Calculating...</div>`;
            }

            // Create level display if Level is available
            const levelHtml = member.Level ? `<div class="member-level">Lv ${member.Level}</div>` : '';

            return `
                <div class="member-row">
                    <div class="status-dot ${statusClass}"></div>
                    <div class="member-name">${memberNameHtml}</div>
                    ${levelHtml}
                    ${statusText ? `<div class="member-status">${statusText}</div>` : ''}
                    ${countdownHtml}
                </div>
            `;
        }

        function createLocationTabs(locationData, locationId) {
            const travelingMembers = locationData.Traveling;
            const locatedMembers = locationData['Located In'];
            const travelingCount = travelingMembers.length;
            const locatedCount = locatedMembers.length;

            const travelingMembersHtml = travelingMembers.map(member => createMemberRow(member, locationId)).join('') || '<div class="empty-section">No members traveling</div>';
            const locatedMembersHtml = locatedMembers.map(member => createMemberRow(member, locationId)).join('') || '<div class="empty-section">No members located</div>';

            const travelingId = `${locationId}-traveling`;
            const locatedId = `${locationId}-located`;

            // Determine which tab should be active by default
            // Default to "Located in", but if nobody is located and someone is traveling, show traveling
            const defaultToLocated = locatedCount > 0 || travelingCount === 0;
            const travelingActive = !defaultToLocated ? 'active' : '';
            const locatedActive = defaultToLocated ? 'active' : '';

            return `
                <div class="tab-container">
                    <div class="tab-header ${travelingActive}" onclick="switchTab('${locationId}', 'traveling')">
                        <span>Traveling to</span>
                        <span class="count">${travelingCount}</span>
                    </div>
                    <div class="tab-header ${locatedActive}" onclick="switchTab('${locationId}', 'located')">
                        <span>Located in</span>
                        <span class="count">${locatedCount}</span>
                    </div>
                </div>
                <div class="sort-controls">
                    <span class="sort-label">Sort:</span>
                    <div class="sort-option active" onclick="applySorting('${locationId}', 'level', 'desc')">Level â†“</div>
                    <div class="sort-option" onclick="applySorting('${locationId}', 'level', 'asc')">Level â†‘</div>
                    <span class="sort-divider">|</span>
                    <div class="sort-option" onclick="applySorting('${locationId}', 'countdown', 'desc')">Countdown â†“</div>
                    <div class="sort-option" onclick="applySorting('${locationId}', 'countdown', 'asc')">Countdown â†‘</div>
                </div>
                <div class="tab-content ${travelingActive}" id="${travelingId}" data-members='${JSON.stringify(travelingMembers).replace(/'/g, "&apos;")}'>
                    ${travelingMembersHtml}
                </div>
                <div class="tab-content ${locatedActive}" id="${locatedId}" data-members='${JSON.stringify(locatedMembers).replace(/'/g, "&apos;")}'>
                    ${locatedMembersHtml}
                </div>
            `;
        }

        function createLocationSection(locationName, locationData) {
            const travelingCount = locationData.Traveling.length;
            const locatedCount = locationData['Located In'].length;
            const totalCount = travelingCount + locatedCount;

            const locationId = `location-${locationName.replace(/\s+/g, '-').toLowerCase()}`;

            const tabsContent = createLocationTabs(locationData, locationId);

            return `
                <div class="location-section">
                    <div class="location-header expanded" onclick="toggleLocation('${locationId}')">
                        <span>${locationName}</span>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 0.9em;">${totalCount} ${totalCount === 1 ? 'member' : 'members'}</span>
                            <span class="expand-icon">â–¼</span>
                        </div>
                    </div>
                    <div class="location-content expanded" id="${locationId}">
                        ${tabsContent}
                    </div>
                </div>
            `;
        }

        function toggleLocation(locationId) {
            const content = document.getElementById(locationId);
            const header = content.previousElementSibling;

            content.classList.toggle('expanded');
            header.classList.toggle('expanded');
        }

        function switchTab(locationId, tabType) {
            // Get all tab headers and contents for this location
            const locationElement = document.getElementById(locationId);
            const tabHeaders = locationElement.querySelectorAll('.tab-header');
            const tabContents = locationElement.querySelectorAll('.tab-content');

            // Remove active class from all tabs
            tabHeaders.forEach(header => header.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            const activeTabIndex = tabType === 'traveling' ? 0 : 1;
            tabHeaders[activeTabIndex].classList.add('active');
            tabContents[activeTabIndex].classList.add('active');

            // Apply current sorting to the newly active tab
            const activeSortButton = locationElement.parentElement.querySelector('.sort-option.active');
            if (activeSortButton) {
                const sortText = activeSortButton.textContent;
                let sortBy, sortOrder;

                if (sortText.includes('Level')) {
                    sortBy = 'level';
                    sortOrder = sortText.includes('â†“') ? 'desc' : 'asc';
                } else {
                    sortBy = 'countdown';
                    sortOrder = sortText.includes('â†“') ? 'desc' : 'asc';
                }

                // Apply sorting without updating button states (they're already correct)
                applySortingToTab(locationId, sortBy, sortOrder, false);
            }
        }

        function applySortingToTab(locationId, sortBy, sortOrder, updateButtons = true) {
            if (updateButtons) {
                updateSortButtonStates(locationId, sortBy, sortOrder);
            }

            // Get the currently active tab
            const locationElement = document.getElementById(locationId);
            const activeTabContent = locationElement.querySelector('.tab-content.active');

            if (!activeTabContent) return;

            // Get members data from the data attribute
            const membersDataStr = activeTabContent.getAttribute('data-members');
            if (!membersDataStr) return;

            let members;
            try {
                members = JSON.parse(membersDataStr);
            } catch (e) {
                console.error('Error parsing members data:', e);
                return;
            }

            // Sort the members array
            const sortedMembers = sortMembers(members, sortBy, sortOrder);

            // Re-render the member rows with sorted data
            const sortedMembersHtml = sortedMembers.map(member => createMemberRow(member, locationId)).join('') || '<div class="empty-section">No members</div>';
            activeTabContent.innerHTML = sortedMembersHtml;

            // Restart countdown timers for the new content
            startRealtimeCountdowns();
        }

        function formatDateTime(isoString) {
            const date = new Date(isoString);
            return date.toLocaleString();
        }

        // Save current tab states for all locations
        function saveTabStates() {
            const tabStates = {};
            const locationSections = document.querySelectorAll('.location-section');

            locationSections.forEach(section => {
                const locationHeader = section.querySelector('.location-header');
                if (locationHeader) {
                    const locationName = locationHeader.querySelector('span').textContent;
                    const activeTab = section.querySelector('.tab-header.active');
                    if (activeTab) {
                        const tabText = activeTab.querySelector('span').textContent;
                        tabStates[locationName] = tabText;
                    }
                }
            });

            return tabStates;
        }

        // Restore tab states after DOM update
        function restoreTabStates(savedStates) {
            if (!savedStates || Object.keys(savedStates).length === 0) {
                return;
            }

            const locationSections = document.querySelectorAll('.location-section');

            locationSections.forEach(section => {
                const locationHeader = section.querySelector('.location-header');
                if (locationHeader) {
                    const locationName = locationHeader.querySelector('span').textContent;
                    const savedTab = savedStates[locationName];

                    if (savedTab) {
                        const locationContent = section.querySelector('.location-content');
                        const locationId = locationContent.id;

                        // Determine which tab to activate based on saved state
                        const tabType = savedTab === 'Traveling to' ? 'traveling' : 'located';
                        switchTab(locationId, tabType);
                    }
                }
            });
        }


        // Start or restart auto-refresh with dynamic interval
        function startAutoRefresh(intervalSeconds) {
            // Clear existing interval if any
            if (currentIntervalId) {
                clearInterval(currentIntervalId);
            }

            // Update refresh interval if it changed
            refreshInterval = intervalSeconds * 1000; // Convert to milliseconds

            // Start new interval
            currentIntervalId = setInterval(loadData, refreshInterval);

            console.log(`Auto-refresh started with ${intervalSeconds} second interval`);
        }

        // Sorting functionality
        function applySorting(locationId, sortBy, sortOrder) {
            applySortingToTab(locationId, sortBy, sortOrder, true);
        }

        function updateSortButtonStates(locationId, activeSortBy, activeSortOrder) {
            const locationElement = document.getElementById(locationId).parentElement;
            const sortButtons = locationElement.querySelectorAll('.sort-option');

            // Remove active class from all buttons
            sortButtons.forEach(button => button.classList.remove('active'));

            // Add active class to the clicked button
            const activeButtonText = activeSortBy === 'level'
                ? (activeSortOrder === 'desc' ? 'Level â†“' : 'Level â†‘')
                : (activeSortOrder === 'desc' ? 'Countdown â†“' : 'Countdown â†‘');

            sortButtons.forEach(button => {
                if (button.textContent === activeButtonText) {
                    button.classList.add('active');
                }
            });
        }

        function sortMembers(members, sortBy, sortOrder) {
            return members.slice().sort((a, b) => {
                let valueA, valueB;

                if (sortBy === 'level') {
                    valueA = a.Level || 0;
                    valueB = b.Level || 0;
                } else if (sortBy === 'countdown') {
                    // Parse countdown values for sorting (convert to seconds)
                    valueA = parseCountdownToSeconds(a.Arrival || a.Until || a.Countdown || '');
                    valueB = parseCountdownToSeconds(b.Arrival || b.Until || b.Countdown || '');
                }

                if (sortOrder === 'asc') {
                    return valueA - valueB;
                } else {
                    return valueB - valueA;
                }
            });
        }

        function parseCountdownToSeconds(timeStr) {
            if (!timeStr) return 0;

            // Handle different time formats
            if (timeStr.includes('T')) {
                // ISO format - calculate difference from now
                const targetTime = new Date(timeStr).getTime();
                const currentTime = Date.now();
                return Math.max(0, (targetTime - currentTime) / 1000);
            }

            // Handle H:MM:SS format
            const parts = timeStr.split(':');
            if (parts.length === 3) {
                const hours = parseInt(parts[0], 10) || 0;
                const minutes = parseInt(parts[1], 10) || 0;
                const seconds = parseInt(parts[2], 10) || 0;
                return hours * 3600 + minutes * 60 + seconds;
            }

            return 0;
        }

        // Enhanced loadData function that handles dynamic intervals
        async function loadData() {
            // Fetch fresh data from API
            const data = await fetchData();
            if (!data) {
                console.error('No data received from API');
                return;
            }

            currentData = data;

            // Check if interval changed and restart auto-refresh if needed
            if (data.Interval && data.Interval !== (refreshInterval / 1000)) {
                console.log(`Interval changed from ${refreshInterval / 1000}s to ${data.Interval}s`);
                startAutoRefresh(data.Interval);
            }

            // Set header information
            document.getElementById('faction-name').textContent = currentData.Faction;
            document.getElementById('last-updated').textContent = `Last updated: ${formatDateTime(currentData.Updated)}`;
            document.getElementById('update-interval').textContent = `Update interval: ${currentData.Interval || 60} seconds`;

            // Save current tab states before updating
            const currentTabStates = saveTabStates();

            // Generate location sections - Torn always last
            const container = document.getElementById('locations-container');
            const locations = Object.entries(currentData.Locations);

            // Sort locations: Torn last, others alphabetically
            const sortedLocations = locations.sort(([nameA], [nameB]) => {
                if (nameA === 'Torn') return 1;
                if (nameB === 'Torn') return -1;
                return nameA.localeCompare(nameB);
            });

            const locationsHtml = sortedLocations
                .map(([locationName, locationData]) => createLocationSection(locationName, locationData))
                .join('');

            container.innerHTML = locationsHtml;

            // Restore tab states after updating
            restoreTabStates(currentTabStates);

            // Start realtime countdown updates
            startRealtimeCountdowns();
        }

        // Load data when page loads and start auto-refresh
        document.addEventListener('DOMContentLoaded', async function() {
            await loadData();

            // Start auto-refresh with interval from API, fallback to 60 seconds
            const initialInterval = currentData?.Interval || 60;
            startAutoRefresh(initialInterval);
        });
    </script>
</body>
</html>